<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="com.obiscr.chatgpt.settings.EasyCodeState">
    <option name="projectFiles" value="$PROJECT_DIR$/Assets/Joystick Pack/Examples/JoystickPlayerExample.cs;C:/UnityProjects/Final/FinalProject/Assets/Joystick Pack/Examples/JoystickSetterExample.cs;C:/UnityProjects/Final/FinalProject/Assets/Joystick Pack/Scripts/Base/Joystick.cs;C:/UnityProjects/Final/FinalProject/Assets/Joystick Pack/Scripts/Editor/DynamicJoystickEditor.cs;C:/UnityProjects/Final/FinalProject/Assets/Joystick Pack/Scripts/Editor/FloatingJoystickEditor.cs;C:/UnityProjects/Final/FinalProject/Assets/Joystick Pack/Scripts/Editor/JoystickEditor.cs;C:/UnityProjects/Final/FinalProject/Assets/Joystick Pack/Scripts/Editor/VariableJoystickEditor.cs;C:/UnityProjects/Final/FinalProject/Assets/Joystick Pack/Scripts/Joysticks/DynamicJoystick.cs;C:/UnityProjects/Final/FinalProject/Assets/Joystick Pack/Scripts/Joysticks/FixedJoystick.cs;C:/UnityProjects/Final/FinalProject/Assets/Joystick Pack/Scripts/Joysticks/FloatingJoystick.cs;C:/UnityProjects/Final/FinalProject/Assets/Joystick Pack/Scripts/Joysticks/VariableJoystick.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/Animation/Animations.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/Attack/MeleeAttack.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/Attack/Shoot.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/Bullets/Bullet.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/Camera/CameraMove.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/Components/MovementComponent.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/Components/PerceptionComponent.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/DamageSystem/DamageSystem.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/Enemy/Enemy.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/Enemy/FightAI.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/HealthSystem/HealthBar.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/HealthSystem/HealthSystem.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/JoystickLogic/JoystickMovement.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/MineObjects/Building.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/MineObjects/MineObjects.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/MineObjects/TreeMine.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/Player/BasePlayer.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/Player/Experience.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/Player/PlayerInput.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/Player/Stats.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/Pools/AmmoPool.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/Pools/ObjectsPool.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/Pools/Pool.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/UI/CreateItems.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/UI/InventorySlot.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/UI/Items.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/UI/StatsCreateRange.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/UI/UI.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/DamageableObject.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/ExperienceForDeath.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/Spawn.cs;C:/UnityProjects/Final/FinalProject/Assets/Scripts/SpawnZone.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/Benchmark01.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/Benchmark01_UGUI.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/Benchmark02.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/Benchmark03.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/Benchmark04.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/CameraController.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/ChatController.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/DropdownSample.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/EnvMapAnimator.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/ObjectSpin.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/ShaderPropAnimator.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/SimpleScript.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/SkewTextExample.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/TeleType.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/TextConsoleSimulator.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/TextMeshProFloatingText.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/TextMeshSpawner.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/TMP_DigitValidator.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/TMP_ExampleScript_01.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/TMP_FrameRateCounter.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/TMP_PhoneNumberValidator.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/TMP_TextEventCheck.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/TMP_TextEventHandler.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/TMP_TextInfoDebugTool.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/TMP_TextSelector_A.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/TMP_TextSelector_B.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/TMP_UiFrameRateCounter.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/TMPro_InstructionOverlay.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/VertexColorCycler.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/VertexJitter.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/VertexShakeA.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/VertexShakeB.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/VertexZoom.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Examples &amp; Extras/Scripts/WarpTextExample.cs;C:/UnityProjects/Final/FinalProject/Assets/TextMesh Pro/Sprites/EmojiOne.json;C:/UnityProjects/Final/FinalProject/Packages/manifest.json;C:/UnityProjects/Final/FinalProject/Packages/packages-lock.json;C:/UnityProjects/Final/FinalProject/ProjectSettings/Packages/com.unity.testtools.codecoverage/Settings.json;C:/UnityProjects/Final/FinalProject/ProjectSettings/SceneTemplateSettings.json" />
    <option name="forceFullIndex" value="false" />
    <option name="fileSummaryMaps" value="{&quot;C:/UnityProjects/Final/FinalProject&quot;:&quot;{\&quot;/Assets/Joystick Pack/Scripts/Editor/JoystickEditor.cs\&quot;:\&quot;This file contains a custom editor script for the Joystick component.\\n\\nKey things it does:\\n\\n- Defines a custom editor for the Joystick component using the [CustomEditor] attribute.\\n\\n- OnEnable() method finds and caches the serialized properties it needs to edit.\\n\\n- OnInspectorGUI() draws the inspector GUI for the joystick properties:\\n\\n  - DrawValues() draws the handle range, deadzone, axis options, snap properties\\n\\n  - DrawComponents() draws the background and handle object references\\n\\n- Applies any modified properties after editing\\n\\n- Ensures the handle RectTransform is centered/anchored properly\\n\\nKey functions:\\n\\n- OnEnable() - Finds serialized properties\\n- OnInspectorGUI() - Main inspector GUI drawing method  \\n- DrawValues() - Draws value properties\\n- DrawComponents() - Draws component references\\n\\nSo in summary, it provides a custom inspector GUI for configuring the Joystick component properties.\&quot;,\&quot;/Assets/Joystick Pack/Scripts/Joysticks/DynamicJoystick.cs\&quot;:\&quot;This file contains a DynamicJoystick class that inherits from the Joystick class. It is used to create a dynamic joystick input for mobile games.\\n\\nKey functions:\\n\\n- Start() - Sets the MoveThreshold property and hides the background object on start.\\n\\n- OnPointerDown() - Sets the background anchored position and shows it when the joystick is pressed. \\n\\n- OnPointerUp() - Hides the background when the joystick is released.\\n\\n- HandleInput() - Handles joystick input. If the magnitude is greater than the threshold, it moves the background further based on the input. Otherwise it calls the base HandleInput().\\n\\n- MoveThreshold property - Threshold for considering joystick input as movement.\\n\\nThe main purpose is to allow the joystick background graphic to dynamically move further based on the strength of input, rather than just sticking to the edge. This gives a more responsive feeling joystick for mobile games.\&quot;,\&quot;/Assets/Scripts/Animation/Animations.cs\&quot;:\&quot;This Animations script controls character animations in Unity.\\n\\nKey functions:\\n\\n- Start() - Gets the Animator component on the gameobject.\\n\\n- Update() - Sets the \\\&quot;Speed\\\&quot; float parameter on the Animator based on if the character is moving or not.\\n\\n- SetMovement() - Sets the movement vector that is checked in Update().\\n\\n- AttackAnimation() - Triggers the \\\&quot;Attack\\\&quot; or \\\&quot;StopAttack\\\&quot; trigger parameters on the Animator based on the attackState bool. \\n\\n- MineTreeAnimation() - Triggers the \\\&quot;MineTree\\\&quot; or \\\&quot;StopMining\\\&quot; trigger parameters on the Animator based on the mineState bool.\\n\\nIn summary, it:\\n\\n- Gets the Animator component\\n- Updates a \\\&quot;Speed\\\&quot; parameter based on movement \\n- Allows setting the movement vector\\n- Triggers attack and mining animations via parameters\\n\\nSo it controls character locomotion and action animations by setting parameters and triggering events on the Animator component.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/TMP_TextInfoDebugTool.cs\&quot;:\&quot;This TMP_TextInfoDebugTool script is used for debugging Text Mesh Pro text components in the Unity editor.\\n\\nKey functions:\\n\\n- OnDrawGizmos() - Main drawing function called in the editor. Handles drawing all the debug visualizations.\\n\\n- DrawCharactersBounds() - Draws rectangles around each character. Also draws character metrics like ascender, descender lines. \\n\\n- DrawWordBounds() - Draws rectangles around each word.\\n\\n- DrawLinkBounds() - Draws rectangles around each link. \\n\\n- DrawLineBounds() - Draws lines for ascender, descender, baseline of each line. \\n\\n- DrawBounds() - Draws rectangle around the text mesh bounds.\\n\\n- DrawTextBounds() - Draws rectangle around the actual rendered text bounds. \\n\\n- Various drawing helper functions like DrawRectangle(), DrawDottedRectangle() to actually draw the debug shapes.\\n\\nIt provides visualizations of the underlying text component text info like characters, words, links, lines etc to help debug text layout and formatting issues in the editor. The debug shapes are only drawn in the editor and not in builds.\&quot;,\&quot;/Assets/Scripts/Player/BasePlayer.cs\&quot;:\&quot;This BasePlayer class is a base class for player characters in the game. It handles player input and movement.\\n\\nKey things it does:\\n\\n- Handles player input from the PlayerInput system using InputAction callbacks for move input\\n- Stores the movement vector from input \\n- Has a reference to the MovementComponent for handling actual movement\\n- Has an Animator component for playing animations\\n- Updates the transform rotation to face the movement direction\\n- Implements health/damage functionality by overriding the GetHealthSystem method\\n\\nKey functions:\\n\\n- Start() - Initializes player input and registers input callbacks\\n- Move_performed/Move_canceled - Handles setting/clearing the movement vector from input  \\n- Update() - Updates movement, animations, and rotation each frame\\n- GetHealthSystem() - Returns the HealthSystem component for damage handling\\n\\nSo in summary, it provides the core functionality for a player character - handling input, movement, animations and health. Child classes would implement specific movement, abilities etc.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/SkewTextExample.cs\&quot;:\&quot;This file contains a script that warps and skews the text in a TMP_Text component over time based on animation curves and values.\\n\\nKey functions:\\n\\n- WarpText(): The main coroutine that runs the text warping logic. Iterates through each character and modifies the vertex positions.\\n\\n- CopyAnimationCurve(): Copies an AnimationCurve so it can be compared over frames to detect changes. \\n\\n- ForceMeshUpdate(): Forces the TMP component to regenerate its mesh, populating the text info data.\\n\\n- UpdateVertexData(): Uploads the modified vertex data back to the TMP component mesh.\\n\\nThe main logic warps each character\\u0027s vertices based on:\\n\\n- An AnimationCurve to determine the warp amount \\n- A shear amount value\\n- Character position and bounds calculations\\n- Matrix transforms to apply the warping\\n\\nThis animates the text mesh vertices over time to warp and skew the text shape.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/Benchmark01_UGUI.cs\&quot;:\&quot;This file contains a script that benchmarks the performance of TextMeshPro vs regular Text component in Unity.\\n\\nKey things it does:\\n\\n- Allows selecting between benchmarking TextMeshPro (BenchmarkType 0) or regular Text (BenchmarkType 1)\\n\\n- Adds either a TextMeshProUGUI or Text component to the game object and configures basic properties like font, size, alignment\\n\\n- Loops 1 million times, updating the text on each iteration to display a changing number \\n\\n- For TextMeshPro, it also alternates between two different font materials on each 1000 count to measure impact of material changes\\n\\n- Yields between iterations to allow frame to render and not block\\n\\nKey functions:\\n\\n- Start() - Sets up the TextMeshPro or Text component and runs the benchmark loop\\n- Update() - Not used, but would update the text value each frame\\n- label01, label02 - Sample text strings used in benchmark\\n- m_textMeshPro, m_textMesh - References to the TextMeshPro or Text components\\n\\nSo in summary, it provides a simple but repeatable way to benchmark text rendering performance between the two approaches.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/TMP_TextSelector_B.cs\&quot;:\&quot;This file contains a script called TMP_TextSelector_B that handles selecting and highlighting characters, words and links in a TextMeshPro text object.\\n\\nKey functions:\\n\\n- Awake() - Gets references to the TextMeshPro component, Canvas, camera. Creates a popup text object.\\n\\n- OnEnable()/OnDisable() - Subscribes/unsubscribes to the TEXT_CHANGED_EVENT to update cached vertex data. \\n\\n- ON_TEXT_CHANGED() - Called when text is changed, updates cached vertex data.\\n\\n- LateUpdate() - Handles mouse input:\\n\\n  - Character selection - Finds intersecting character, highlights it by scaling vertices.\\n\\n  - Word selection - Finds intersecting word, highlights by tinting vertex colors.\\n\\n  - Link selection - Finds intersecting link, displays popup text.\\n\\n- Pointer event handlers - Handles pointer enter/exit/click/up. \\n\\n- RestoreCachedVertexAttributes() - Restores original vertex data when selection is cleared.\\n\\nSo in summary, it allows selecting/highlighting text elements and displays link popups by modifying the TextMeshPro vertex data on mouse input.\&quot;,\&quot;/Assets/Scripts/Camera/CameraMove.cs\&quot;:\&quot;This CameraMove script controls the movement of the camera in the scene based on the position of a player object.\\n\\nKey things it does:\\n\\n- It has a public BasePlayer variable called \\\&quot;player\\\&quot; that references the player object it will follow.\\n\\n- In the Update() function, it gets the position of the player transform and sets the x and z positions of the camera to match the player, while keeping the y position the same. It offsets the z position by -7f to position the camera behind the player. \\n\\n- This has the effect of smoothly moving the camera to follow directly behind the player object as it moves around in the scene.\\n\\nKey functions:\\n\\n- Update() - Called every frame to update the camera position based on the player position.\\n\\n- transform.position - Gets/sets the position of the camera transform to reposition it each frame. \\n\\n- player.transform.position - Gets the current position of the player transform to base the camera position off of.\\n\\nSo in summary, it is a simple third person camera controller script that smoothly follows a player object by constantly updating its position each frame.\&quot;,\&quot;/Assets/Scripts/Pools/ObjectsPool.cs\&quot;:\&quot;This ObjectsPool script manages object pooling for prefabs in Unity.\\n\\nKey functions:\\n\\n- Awake(): Called when the script instance is initialized. It pools (instantiates) the number of prefabs specified by amountToPool and stores them in the pooledObjects list.\\n\\n- GetPooledObjects(): Returns an inactive/unused prefab object from the pool. Loops through pooledObjects and returns the first inactive one.\\n\\nKey properties:\\n\\n- prefab: The prefab to pool instances of. \\n\\n- amountToPool: Number of prefab instances to pool initially.\\n\\n- pooledObjects: List that stores the pooled prefab gameobjects.\\n\\nWhat it does:\\n\\n- Implements object pooling pattern to reuse prefab instances instead of destroying/instantiating them. \\n\\n- On startup it instantiates the number needed and stores references. \\n\\n- GetPooledObjects returns an inactive pooled object for reuse instead of instantiating a new one. This improves performance by avoiding allocations.\\n\\nSo in summary, it manages a pool of prefab instances that can be reused instead of constantly creating/destroying gameobjects.\&quot;,\&quot;/Assets/Scripts/Bullets/Bullet.cs\&quot;:\&quot;This Bullet.cs script controls the behavior of bullet gameobjects in Unity.\\n\\nKey functions:\\n\\n- Update() - Each frame, sets the bullet\\u0027s velocity to point towards the target transform if one is set.\\n\\n- Shoot(Vector3 dir) - Called when firing, adds an initial force in the direction passed in to launch the bullet. Resets velocity. \\n\\n- SetTarget(Transform newTarget) - Sets the target the bullet should track towards. \\n\\n- OnTriggerEnter(Collider other) - Called when the bullet collides with another collider, deactivates the bullet gameobject.\\n\\nThis script allows bullets to be fired from a weapon, track towards a target enemy if set, and deactivate on collision with something to represent being destroyed. The rigidbody component is used to apply physics forces to move the bullet in a realistic ballistic trajectory.\&quot;,\&quot;/Assets/Scripts/HealthSystem/HealthBar.cs\&quot;:\&quot;This HealthBar script is used to display a health bar UI element that represents the health of a HealthSystem component.\\n\\nKey functions:\\n\\n- Awake(): Finds references to the health bar image and text components. Subscribes to the HealthSystem\\u0027s OnHealthChanged event.\\n\\n- OnHealthChanged(float percentageHealth): Called when health changes on the HealthSystem. Updates the fill amount of the health bar image and displays the current health value. \\n\\n- LateUpdate(): Continuously updates the text to display the current health value from the HealthSystem. Orients the health bar to always face the camera.\\n\\nSo in summary, it connects a UI health bar to a HealthSystem component, updating the bar visually whenever health changes on that system. It displays the current numeric health value and orients the bar towards the camera. This allows a health bar to dynamically represent the health status of a game object using the HealthSystem.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/TMP_DigitValidator.cs\&quot;:\&quot;This file defines a custom input validator class called TMP_DigitValidator for TextMeshPro that only allows digits (0-9) to be entered as input.\\n\\nKey functions:\\n\\n- It inherits from TMP_InputValidator which defines the base input validation behavior.\\n\\n- It overrides the Validate method which is called whenever a character is entered as input. \\n\\n- Validate checks if the character is a digit between 0-9. If so, it appends the character to the text and increments the position. It returns the character.\\n\\n- If the character is not a digit, it returns (char)0 which effectively rejects the character.\\n\\n- This allows only digits to be entered as input when this validator is used, blocking all other characters from being accepted.\\n\\nSo in summary, it provides a custom input validation logic that filters input to only allow digits, by overriding the Validate method from the base validator class. This can then be assigned to TextMeshPro text components to restrict input to digits only.\&quot;,\&quot;/Assets/TextMesh Pro/Sprites/EmojiOne.json\&quot;:\&quot;This file is a JSON sprite sheet definition file for EmojiOne emojis.\\n\\nKey functions:\\n\\n- Defines the individual sprite frames within the larger sprite sheet image. Each frame specifies the coordinates, size, pivot point etc. \\n\\n- Allows individual sprite frames to be identified and extracted by their filename/emoji codepoint.\\n\\n- Provides metadata about the overall sprite sheet like the image file name, format, total size.\\n\\n- Lets a game/app engine know how to load and render the individual emoji sprites from the larger sprite sheet texture.\\n\\n- Standardizes the emoji sprite data so it can be used across different engines/platforms that support JSON sprite sheets.\\n\\n- Makes it easy to add/remove emoji sprites without re-exporting the whole sheet, by just modifying the frame data in this file.\\n\\nSo in summary, it defines the layout and provides access to individual emoji sprites within a larger optimized sprite sheet texture, in a way that can be easily used by different game/rendering engines.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/Benchmark01.cs\&quot;:\&quot;This file contains a script that benchmarks the performance of TextMeshPro vs TextMesh in Unity.\\n\\nKey things it does:\\n\\n- Sets up a BenchmarkType variable to select whether to use TextMeshPro (0) or TextMesh (1)\\n\\n- On start:\\n\\n  - Adds a TextMeshPro or TextMesh component based on BenchmarkType\\n\\n  - Configures font, size, alignment etc of the text component\\n\\n  - Stores materials for font swapping on TextMeshPro\\n\\n- Runs a coroutine loop that:\\n\\n  - Sets the text to a formatted string with the index % 1000\\n\\n  - Swaps the font material on TextMeshPro every 1000 iterations\\n\\n  - Yields to not block the main thread\\n\\n- Main functions:\\n\\n  - Start() - Sets up and runs the benchmark coroutine\\n\\n  - SetText() - Sets the text value on TextMeshPro\\n\\n  - text property - Sets the text value on TextMesh\\n\\nSo in summary, it benchmarks text updating performance by rapidly changing the displayed text value over 1 million iterations for both TextMeshPro and TextMesh components.\&quot;,\&quot;/ProjectSettings/SceneTemplateSettings.json\&quot;:\&quot;This file (SceneTemplateSettings.json) contains settings that control how assets are instantiated and handled in scene templates in Unity.\\n\\nKey functions:\\n\\n- templatePinStates - Stores the pin states of assets in scene templates. Pins determine if an asset is shared or instance across scenes.\\n\\n- dependencyTypeInfos - Defines how different asset types are instantiated by default when a scene template is used to create a new scene. It specifies if the asset is instantiated (0) or shared (1).\\n\\n- defaultDependencyTypeInfo - The default behavior for any asset type not explicitly defined above. \\n\\n- newSceneOverride - Determines if the template settings override the default settings for new scenes not based on a template. \\n\\n- It allows Unity to intelligently instantiate/share assets like materials, prefabs, animations etc. across scenes based on their type when using scene templates to create new scenes. This prevents duplicating large asset files across scenes unintentionally.\\n\\nSo in summary, it controls the default asset handling behaviors for scene templates in Unity to optimize asset usage across multiple scenes.\&quot;,\&quot;/Assets/Scripts/Components/MovementComponent.cs\&quot;:\&quot;This MovementComponent script controls character movement in a game.\\n\\nIt does the following:\\n\\n- Stores a reference to the CharacterController component on the game object.\\n\\n- Gets the Stats component to access movement speed. \\n\\n- Applies gravity to the y component of movement each frame.\\n\\n- Moves the character by the input movement vector multiplied by speed and delta time. \\n\\nKey functions:\\n\\n- Move(Vector3 movement) - Moves the character controller based on input movement vector. Applies gravity and movement speed.\\n\\n- Private CharacterController Controller property - Gets the character controller component lazily.\\n\\n- Start() - Gets the Stats component reference.\\n\\nSo in summary, it handles applying movement input, gravity and speed calculations to move the character controller each frame based on player input and stats.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/EnvMapAnimator.cs\&quot;:\&quot;This file contains a script that animates the environment map texture on a Text Mesh Pro object.\\n\\nKey functions:\\n\\n- Awake() - Gets a reference to the Text Mesh Pro component and its material.\\n\\n- Start() - Runs an infinite coroutine that updates the environment map matrix over time:\\n\\n  - It constructs a matrix using SetTRS, setting the rotation to rotate around each axis based on the RotationSpeeds property over time. \\n\\n  - The matrix is applied to the \\\&quot;_EnvMatrix\\\&quot; property on the material to animate the environment map texture.\\n\\n  - Yields null each frame to allow the animation to run over multiple frames.\\n\\n- RotationSpeeds property - Defines the rotation speed around each axis to drive the animation.\\n\\nSo in summary, it continuously rotates the environment map texture on the material by updating the \\\&quot;_EnvMatrix\\\&quot; property each frame based on the RotationSpeeds, effectively animating the environment reflection over time.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/TextConsoleSimulator.cs\&quot;:\&quot;This file contains a script that simulates a text console by revealing text character by character or word by word over time.\\n\\nKey functions:\\n\\n- RevealCharacters(): Reveals the text one character at a time by incrementing the maxVisibleCharacters property on each frame.\\n\\n- RevealWords(): Reveals the text one word at a time by calculating the index of the last character in each word and setting maxVisibleCharacters accordingly. \\n\\n- ON_TEXT_CHANGED(): Event handler that fires when the text content changes, used to reset the reveal process. \\n\\n- Start(): Starts one of the reveal coroutines.\\n\\n- OnEnable/OnDisable(): Subscribes/unsubscribes to the TEXT_CHANGED event to detect text changes.\\n\\nSo in summary, it simulates a console-like reveal of text content over time for a TextMeshPro text object, either character by character or word by word, handling text changes as well.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/TMP_FrameRateCounter.cs\&quot;:\&quot;This file contains a script that displays a frame rate counter overlay in a Unity scene.\\n\\nKey functions:\\n\\n- Awake(): Initializes the frame counter gameobject, TextMeshPro component, font, material, and sets up the transform hierarchy.\\n\\n- Start(): Resets frame count and timer variables. \\n\\n- Update(): Increments frame count, calculates FPS and MS every interval, formats and displays text using HTML color tags.\\n\\n- Set_FrameCounter_Position(): Positions the frame counter text based on the selected anchor position enum. Sets pivot, alignment and world position.\\n\\nIt uses TextMeshPro to display formatted text with color coded FPS values overlaid in the scene viewport. The update interval, position and colors are configurable. It provides a simple way to monitor performance during development.\&quot;,\&quot;/Assets/Scripts/JoystickLogic/JoystickMovement.cs\&quot;:\&quot;This JoystickMovement script controls player movement and animation based on input from a virtual joystick.\\n\\nKey functions:\\n\\n- Start() - Gets a reference to the Animations component.\\n\\n- Update() - Called every frame:\\n\\n  - Gets horizontal and vertical input from the joystick.\\n\\n  - Creates a movement vector from the input.\\n\\n  - Calls Move() on the MovementComponent to move the player.\\n\\n  - Calls SetMovement() on Animations to set the movement for animations.\\n\\n  - If moving, rotates the player towards the movement direction.\\n\\n- Move() on MovementComponent - Handles actual player movement. \\n\\n- SetMovement() on Animations - Sets the movement state for animations.\\n\\n- CharacterAnimator property - Gets the Animator component reference.\\n\\nSo in summary, it reads joystick input each frame, moves the player and rotates/animates them based on that input using the MovementComponent and Animations components.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/TMP_ExampleScript_01.cs\&quot;:\&quot;This file contains a script (TMP_ExampleScript_01) that demonstrates how to use Text Mesh Pro components in Unity.\\n\\nKey things it does:\\n\\n- Defines an enum to select between TextMeshPro and TextMeshProUGUI components\\n- Gets a reference to the TMP component on the game object\\n- Loads font and material assets from Resources folder\\n- Sets properties like font, size, text on the TMP component\\n- Gets the preferred size of the text based on width/height constraints\\n- Resizes the RectTransform to match the preferred size\\n- Updates the text by formatting and setting a counter value if not static\\n\\nKey functions:\\n\\n- Awake(): Gets TMP component, loads assets, sets properties, sizes text object\\n- Update(): Updates text by formatting and incrementing counter if not static  \\n- GetPreferredValues(): Gets preferred size of text within constraints\\n- SetText(): Sets the formatted text value\\n\\nSo in summary, it demonstrates basic TMP component setup and text updating/resizing using Text Mesh Pro features.\&quot;,\&quot;/Assets/Scripts/UI/UI.cs\&quot;:\&quot;This UI.cs script controls user interface elements in Unity.\\n\\nIt has one key function:\\n\\nEnableAndDisable(GameObject go)\\n\\nThis function toggles the active state of a GameObject passed into it. It does the following:\\n\\n1. Gets the current active state of the GameObject \\n2. Flips the state (if active it will set to inactive, and vice versa)\\n3. Sets the GameObject\\u0027s active state to the new flipped value\\n\\nSo in summary, this function allows toggling GameObjects like UI panels, buttons etc between an active and inactive state with a single call. This is useful for basic UI interactivity like showing/hiding elements on click.\\n\\nThe key aspects are:\\n\\n- It is attached to a UI manager-type gameobject \\n- Has a single function to toggle GameObject active states\\n- Provides a simple way to enable/disable UI elements from scripts\\n\\nSo in summary, it provides a reusable toggle function to control basic UI interactivity from scripts.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/CameraController.cs\&quot;:\&quot;This CameraController script controls the camera in a 3D scene in Unity.\\n\\nKey functions:\\n\\n- GetPlayerInput(): Gets input from mouse, keyboard, touches to control the camera movement and zooming. Handles rotation, panning, zooming.\\n\\n- LateUpdate(): Moves the camera position and rotation based on input. Provides smoothing options. \\n\\n- Start(): Sets up initial camera target if not assigned. \\n\\n- Awake(): Sets up framerate and input settings.\\n\\n- desiredPosition: Calculates the target position of the camera based on the camera mode (follow, isometric, etc).\\n\\n- MovementSmoothing, RotationSmoothing: Provides smoothing for camera movement and rotation.\\n\\nIt allows controlling the camera position and rotation through various input methods like mouse, touch. Provides different camera modes like follow, isometric. Handles zooming, panning, rotation. Provides smoothing and limits for values like zoom distance, elevation angle.\&quot;,\&quot;/Assets/Scripts/Pools/AmmoPool.cs\&quot;:\&quot;This AmmoPool script is used to pool Bullet prefab objects for reuse in a shooting game.\\n\\nKey functions:\\n\\n- Awake() - Called when the script instance is initialized. It instantiates the specified number of Bullet prefabs from the prefab variable and adds them to the pooledObjects list. Sets their parent to this gameobject and deactivates them.\\n\\n- GetPooledObjects() - Returns the first inactive/unused Bullet object from the pooledObjects list. Loops through the list to find the first inactive one.\\n\\n- amountToPool - Specifies how many Bullet prefabs to pool initially. \\n\\n- prefab - The Bullet prefab to pool.\\n\\n- pooledObjects - List that holds all the pooled Bullet gameobjects.\\n\\nSo in summary, it pools a set number of Bullet prefabs on startup for efficient re-use when bullets need to be spawned in the game. It re-uses inactive pooled objects rather than constantly instantiating new ones.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/VertexShakeA.cs\&quot;:\&quot;This file contains a script that animates the vertex colors of a TextMeshPro text object.\\n\\nKey functions:\\n\\n- AnimateVertexColors(): The main coroutine that performs the animation loop.\\n\\n- ON_TEXT_CHANGED(): Callback that fires when the text object regenerates its mesh. Used to detect text changes. \\n\\n- Start(): Starts the animation coroutine.\\n\\nInside the animation loop it:\\n\\n- Makes a copy of the text vertices.\\n\\n- Loops through each character.\\n\\n- Applies a random scale/rotation transform to the character vertices. \\n\\n- Updates the mesh vertices with the transformed copies.\\n\\n- Yields to smooth out the animation over time.\\n\\nSo in summary, it continuously transforms the character vertices to shake/animate the text mesh, giving it a vibrating/glitchy effect. The callbacks handle detecting when the text changes to reset the animation.\&quot;,\&quot;/Assets/Scripts/Enemy/FightAI.cs\&quot;:\&quot;This FightAI script controls the combat behavior of an enemy character.\\n\\nKey functions:\\n\\n- Start() - Gets references to the MovementComponent and Animations components.\\n\\n- Update() - Gets the enemy\\u0027s current target from the PerceptionComponent.\\n\\n- Fight() - Calls the Attack function to engage the target.\\n\\n- Attack(DamageableObject opponent) - The main combat logic:\\n\\n  - Checks if the enemy is in range using the Shoot component\\n\\n  - If not in range, moves toward the target using the MovementComponent\\n\\n  - Sets the movement animation\\n\\n  - Looks at the target\\n\\n  - If in range, stops movement animation\\n\\nSo in summary, it uses the PerceptionComponent to get the target, then calls Attack() each frame to move toward and engage the target in combat by controlling movement and animations. The Shoot component determines when it can attack vs when it needs to close the distance.\&quot;,\&quot;/Assets/Scripts/HealthSystem/HealthSystem.cs\&quot;:\&quot;This HealthSystem script manages the health of a game object.\\n\\nKey functions:\\n\\n- Init() - Initializes the current health to max health\\n- GetCurrentHealth() - Gets the current health amount \\n- SetAutoHealPeriod(), SetAutoHealValue() - Sets auto heal period and value\\n- FullRestore() - Sets current health to max health\\n- AddHealth(), GetDamage() - Adds or removes health amount\\n- GetMineObjectDamage() - Damages from mine objects  \\n- ChangeHealthIv() - Invokes event with health percentage change\\n- OnRevival() - Resets health on revival\\n- CheckIsDead() - Checks if health is \\u003c\\u003d 0 and invokes Death event\\n- AutoHeal() - Handles auto healing over time\\n- LifeSteal() - Adds life steal amount to current health\\n- Update() - Calls AutoHeal each frame\\n\\nIt manages the max health, current health, auto heal settings, takes damage, heals, checks for death, and invokes events to notify other scripts of changes to the health.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/TMP_TextSelector_A.cs\&quot;:\&quot;This file contains a script called TMP_TextSelector_A that handles text selection and highlighting in a TextMeshPro text object.\\n\\nKey functions:\\n\\n- Awake(): Gets references to the TextMeshPro component and main camera. Forces mesh update.\\n\\n- LateUpdate(): Handles pointer interactions.\\n\\n- Finds intersecting character, link, and word indices based on mouse position. \\n\\n- Highlights selected character by changing its vertex colors. \\n\\n- Handles link selection - changes link color and calls link callback.\\n\\n- Highlights selected word by changing vertex colors of all characters in the word.\\n\\n- OnPointerEnter/Exit: Sets flag for mouse hovering over object.\\n\\nIt demonstrates how to select, highlight and respond to clicks on individual characters, words and links within a TextMeshPro text object using the TMP_TextUtilities helper functions. This allows interactive text selections and links.\&quot;,\&quot;/Assets/Joystick Pack/Scripts/Joysticks/FixedJoystick.cs\&quot;:\&quot;This FixedJoystick.cs file is a script that inherits from the Joystick class. It is used to create a fixed joystick controller in Unity.\\n\\nSome key things about it:\\n\\n- Inherits from Joystick - This allows it to have all the same functionality as a standard Joystick controller but with customized behavior.\\n\\n- No additional functions defined - It does not override or add any new functions compared to the base Joystick class. \\n\\n- Implements a \\\&quot;fixed\\\&quot; joystick - The name and lack of new functions implies it locks the joystick in a fixed position on the screen rather than allowing it to be moved around freely like a standard joystick.\\n\\n- Handles input - Even though it is fixed, it would still handle touch/mouse input to detect when the joystick is being \\\&quot;pressed\\\&quot; in different directions and report the input values back. \\n\\n- Configurable in Inspector - Properties like position, size, etc. could be configured for the fixed joystick in the Unity Inspector to customize its appearance and behavior.\\n\\n- Inherits joystick functionality - Things like detecting input direction, movement range limits, callbacks for input changes would all be provided by the base Joystick class it inherits from.\\n\\nSo in summary, it creates a non-movable joystick controller that reuses the existing joystick functionality but locks it to a fixed on-screen position defined in the Inspector.\&quot;,\&quot;/Assets/Scripts/Attack/MeleeAttack.cs\&quot;:\&quot;This MeleeAttack script controls melee attacking functionality for a game object.\\n\\nKey functions:\\n\\n- OnDrawGizmos - Draws a wire sphere gizmo to visualize the attack range.\\n\\n- Start - Gets a reference to the PerceptionComponent on the same game object. This is used to detect targets.\\n\\n- Update - Calls IsInRange() to check if a target is within attack range. Triggers a melee attack animation if in range. \\n\\n- IsInRange - Calculates distance to the target and sets inRange boolean based on if it\\u0027s less than or equal to the attackRange value.\\n\\n- Target property - Gets the current target from the PerceptionComponent.\\n\\n- attackRange property - Defines the maximum range the object can attack from. \\n\\n- animator property - Reference to the Animator component to play attack animations.\\n\\nSo in summary, it uses a PerceptionComponent to detect targets, checks if the target is in range each frame, and triggers a melee attack animation if the target is close enough. The attack range is visualized as a gizmo for debugging.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/ShaderPropAnimator.cs\&quot;:\&quot;This file contains a script that animates shader properties over time for a Text Mesh Pro object.\\n\\nThe key things it does:\\n\\n- Caches a reference to the renderer and material of the object it is attached to\\n- Starts a coroutine called AnimateProperties\\n- AnimateProperties loops forever, evaluating values from an animation curve and setting the material\\u0027s shader properties each frame\\n- It gets the glow power value from the GlowCurve curve, evaluating it based on the m_frame variable \\n- m_frame increments each frame to animate the curve evaluation over time\\n- Sets the material\\u0027s \\\&quot;GlowPower\\\&quot; shader property to the evaluated glow value\\n\\nKey functions:\\n\\n- Awake() - Caches renderer and material references\\n- Start() - Starts AnimateProperties coroutine \\n- AnimateProperties() - Main coroutine that animates properties each frame\\n- GlowCurve - The animation curve used for the glow animation\\n\\nSo in summary, it animates a shader property (glow power) over time by evaluating an animation curve and setting the material property each frame in a coroutine.\&quot;,\&quot;/Assets/Joystick Pack/Scripts/Editor/FloatingJoystickEditor.cs\&quot;:\&quot;This file defines a custom editor for the FloatingJoystick script.\\n\\nKey things it does:\\n\\n- Derives from JoystickEditor to inherit common joystick editing functionality\\n- Draws the inspector GUI using the base JoystickEditor\\n- Checks if a background image is assigned\\n- Sets the background image RectTransform anchors and pivot to center it properly\\n\\nKey functions:\\n\\n- OnInspectorGUI() - Draws the inspector GUI\\n- Checks for assigned background image\\n- Sets background RectTransform anchorMax/Min to (0,0) to center it \\n- Sets background RectTransform pivot to center\\n\\nSo in summary, it provides a custom editor for FloatingJoystick that draws the standard joystick inspector but also centers any assigned background image properly for a floating joystick style.\&quot;,\&quot;/Assets/Scripts/SpawnZone.cs\&quot;:\&quot;This SpawnZone script is used to heal players when they enter the trigger area of the game object it is attached to.\\n\\nKey functions:\\n\\n- OnTriggerStay - Called when another collider is within the trigger area continuously. Checks if the collider is a player and heals their health by the amount specified in healValue.\\n\\n- healValue - Public float that determines how much health is added to players on each trigger stay frame. \\n\\n- AddHealth - Calls the AddHealth method on the player\\u0027s HealthSystem component to increase their health.\\n\\nSo in summary, it continuously heals any players inside its trigger area by calling the HealthSystem to increase their health by the amount set in healValue each frame. This allows certain zones in a level to regenerate a player\\u0027s health over time.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/Benchmark02.cs\&quot;:\&quot;This file contains a script called Benchmark02 that spawns different types of text objects for benchmarking/performance testing purposes.\\n\\nKey things it does:\\n\\n- Allows setting the number of NPCs (text objects) to spawn via the NumberOfNPC variable\\n- Spawns either TextMeshPro, TextMesh, or Canvas/TextMeshProUGUI text objects depending on the SpawnType variable\\n- Randomly positions the spawned gameobjects \\n- Sets common text properties like color, size, alignment etc\\n- Attaches either a TextMeshProFloatingText or Canvas component to move the text\\n\\nKey functions:\\n\\n- Start() - Main spawn loop that instantiates gameobjects and components\\n- Sets text properties like text, font, color etc\\n- Attaches TextMeshProFloatingText or Canvas component for movement\\n- Allows static or dynamic scaling of text objects\\n\\nSo in summary, it provides a way to benchmark different text rendering systems in Unity by spawning many text objects with common configurations for performance testing/comparison.\&quot;,\&quot;/Assets/Joystick Pack/Scripts/Editor/DynamicJoystickEditor.cs\&quot;:\&quot;This file contains a custom editor script for the DynamicJoystick component in Unity.\\n\\nKey functions:\\n\\n- OnEnable() - Finds the \\\&quot;moveThreshold\\\&quot; serialized property to edit.\\n\\n- OnInspectorGUI() - Overrides the base inspector GUI. Sets the background RectTransform to be anchored at the center. \\n\\n- DrawValues() - Draws the base joystick values first, then draws a field for the \\\&quot;moveThreshold\\\&quot; property. \\n\\nThis custom editor allows editing the DynamicJoystick component directly in the Unity inspector. It overrides some default behavior to center the background and adds a custom field for editing the \\\&quot;moveThreshold\\\&quot; value, which controls how far the input needs to move before the joystick starts moving.\\n\\nSo in summary, it provides a customized inspector UI for the DynamicJoystick component to configure its properties like the move threshold directly in the Unity editor.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/SimpleScript.cs\&quot;:\&quot;This file contains a script that demonstrates basic usage of the TextMeshPro component in Unity.\\n\\nKey things it does:\\n\\n- Adds a TextMeshPro component to the game object it is attached to\\n- Sets various text properties like font size, alignment, auto sizing, etc. \\n- Loads a font asset \\n- Sets the text to display a formatted count that updates each frame\\n- Updates the displayed text each frame by passing the formatted string and current count to SetText()\\n\\nKey functions:\\n\\n- Start() - Initializes the TextMeshPro component and sets up properties\\n- Update() - Updates the displayed text each frame by calling SetText()\\n- SetText() - Sets the actual text being displayed by the TextMeshPro component\\n\\nSo in summary, it demonstrates basic TextMeshPro text display and updating by displaying a counting number that changes each frame. It configures the TextMeshPro properties and fonts and handles updating the text value over time.\&quot;,\&quot;/Assets/Scripts/Pools/Pool.cs\&quot;:\&quot;This Pool.cs script is used to manage object pooling in Unity.\\n\\nObject pooling is a technique used to improve performance by reusing objects instead of destroying and instantiating them. A pool manages a set of inactive objects that can be reactivated and returned to the pool when no longer needed.\\n\\nKey functions this pool script would likely contain:\\n\\n- Populate(): Called on startup to instantiate the initial pool objects.\\n\\n- GetPooledObject(): Gets and returns an inactive object from the pool, reactivating it. \\n\\n- ReturnToPool(): Returns an object to the pool by deactivating it and adding it back to the pool.\\n\\n- ResizePool(): Allows dynamically resizing the pool over time based on demand.\\n\\n- OnObjectSpawn(): Called when an object is spawned from the pool, for initialization. \\n\\n- OnObjectDespawn(): Called when an object returns to the pool, for cleanup.\\n\\nSo in summary, this Pool script would manage the core lifecycle of objects being checked in and out of the pool for efficient reuse during a game. While this specific file is empty, it sets up the base class for pooling functionality.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/ObjectSpin.cs\&quot;:\&quot;This file contains a script called ObjectSpin that spins or moves a game object in various ways.\\n\\nKey functions:\\n\\n- Awake() - Initializes variables like the transform, initial rotation/position, and light color.\\n\\n- Update() - Called every frame:\\n\\n  - If Motion is Rotation, it rotates the object on the y-axis.\\n\\n  - If Motion is BackAndForth, it rotates the object back and forth using sin waves.  \\n\\n  - If Motion is Translation, it moves the object back and forth along x and z axes using sin/cos waves.\\n\\n- MotionType enum - Defines the different motion types (Rotation, BackAndForth, Translation).\\n\\n- SpinSpeed variable - Controls speed of rotation/movement. \\n\\n- RotationRange variable - Controls range of rotation for back and forth motion.\\n\\nSo in summary, it spins or moves a game object in different patterns by manipulating its transform over time based on the selected motion type.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/VertexJitter.cs\&quot;:\&quot;This file contains a script that animates the vertex positions of a Text Mesh Pro text object to jitter/shake the text.\\n\\nKey points:\\n\\n- It attaches to a TMP_Text component and subscribes to text change events.\\n\\n- AnimateVertexColors is a coroutine that continuously updates the vertex positions over time. \\n\\n- It caches the original vertex data so it can modify copies of the vertices.\\n\\n- It computes random animation values like speed and angle range for each character.\\n\\n- On each frame, it loops through each character and calculates a new jittered position by applying a random transform matrix. \\n\\n- The new vertex positions are applied to the text component\\u0027s vertex data.\\n\\n- The updated vertex data is pushed to the text meshes to display the animated jitter effect.\\n\\nKey functions:\\n\\n- AnimateVertexColors() - Main coroutine that runs the animation loop.\\n\\n- ON_TEXT_CHANGED - Handles text regeneration events to re-cache vertex data. \\n\\n- Apply random transforms to vertex positions for each character on each frame.\\n\\nSo in summary, it continuously animates the text vertices to produce a jittering/shaking effect on the text.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/TMP_TextEventCheck.cs\&quot;:\&quot;This file contains a script called TMP_TextEventCheck that handles text selection events for a TMP_Text component.\\n\\nThe key things it does:\\n\\n- Stores a reference to the TMP_TextEventHandler component on the same gameobject.\\n\\n- Gets a reference to the TMP_Text component when enabled. \\n\\n- Adds/removes event listeners for character, word, line, sprite and link selection events.\\n\\n- Contains handler functions for each event type that log details about the selection.\\n\\n- OnCharacterSelection handles character selection events.\\n\\n- OnSpriteSelection handles sprite selection events. \\n\\n- OnWordSelection handles word selection events.\\n\\n- OnLineSelection handles line selection events.\\n\\n- OnLinkSelection handles link selection events and also retrieves link info from the text component.\\n\\nSo in summary, it connects event handlers to the text component\\u0027s selection events and logs details about the selections to the console for debugging purposes.\&quot;,\&quot;/Assets/Scripts/Components/PerceptionComponent.cs\&quot;:\&quot;This PerceptionComponent script handles an entity\\u0027s perception/targeting abilities.\\n\\nKey functions:\\n\\n- GetTargets() - Uses Physics.OverlapSphere to detect objects within the SearchRadius that match the targetMask layer. Adds them to the targets list.\\n\\n- OnDeath() - Removes a target from the targets list if it dies. \\n\\n- GetTarget() - Returns the closest target object by calling ClosestTarget().\\n\\n- ClosestTarget() - Finds the closest target object within the small/big attack ranges and sets the closestObj variable. Checks distance and inRange booleans.\\n\\n- OnDrawGizmos() - Draws visualization spheres for small and big attack ranges. \\n\\n- Start() - Gets the Stats component for attack range values.\\n\\n- Update() - Calls GetTargets() and ClosestTarget() each frame to update perception.\\n\\nSo in summary, it handles detecting nearby targets, tracking the closest one, and providing access to the closest target for attacking/targeting purposes.\&quot;,\&quot;/Assets/Scripts/MineObjects/Building.cs\&quot;:\&quot;This Building script controls the behavior of building game objects in the scene.\\n\\nKey functions:\\n\\n- Mine() - Increases the currentAmountOfResource over time based on mineUpgradeCoef\\n- Collect() - Decreases currentAmountOfResource based on collectSpeed when a player is near \\n- Upgrade() - Upgrades the building by deducting cost from player, increasing price and max resource amount\\n- MineRes() - Coroutine that continuously calls Mine() to simulate mining over time\\n- OnTriggerEnter/Exit/Stay - Detects when a player enters/exits/stays in trigger, shows/hides upgrade button, collects resources\\n\\nOverall it handles:\\n- Mining resources over time \\n- Upgrading building stats and price\\n- Collecting resources when a player is near\\n- Trigger detection for player interaction\\n\\nSo in summary, it controls the core resource mining/collection mechanics and upgrading of a building game object.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/DropdownSample.cs\&quot;:\&quot;This file contains a script that demonstrates how to use TMP_Dropdown components in TextMeshPro.\\n\\nKey things it does:\\n\\n- Declares TextMeshProUGUI and TMP_Dropdown variables to reference the UI elements.\\n\\n- Has an OnButtonClick method that gets the selected values from the dropdowns and displays them in the text element.\\n\\n- Checks if a valid selection was made in both dropdowns before displaying the values.\\n\\n- Uses the .value property on the dropdowns to get the index of the selected option. \\n\\n- Concatenates the selected values into a string to display.\\n\\nSo in summary, it:\\n\\n1. References the UI elements \\n2. Handles button click to get dropdown selections\\n3. Displays the selected values from both dropdowns\\n4. Validates a selection was made before displaying\\n\\nThe main purpose is to demonstrate how to work with TMP_Dropdown components and retrieve/display the selected option values.\&quot;,\&quot;/Assets/Scripts/ExperienceForDeath.cs\&quot;:\&quot;This ExperienceForDeath script handles giving experience points to the player when an enemy is killed.\\n\\nKey functions:\\n\\n- Start() - Adds a callback to the Death event of the HealthSystem script to call the Exp function when the enemy dies.\\n\\n- Exp(GameObject g) - Called when the enemy dies. Gets a reference to the player\\u0027s Experience component and adds the expForKill amount of experience points. \\n\\n- expForKill - Public variable to set how much experience is awarded for killing this enemy.\\n\\nSo in summary, it listens for the enemy\\u0027s death, finds the player, and awards them experience points based on the configured amount. This allows enemies to give experience on death to progress the player\\u0027s level.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/TMP_PhoneNumberValidator.cs\&quot;:\&quot;This file defines a custom input validator class called TMP_PhoneNumberValidator that is used to validate input for phone numbers in a specific format.\\n\\nKey functions:\\n\\n- Validate() - This is the main validation function that is called when a character is input. It checks the character and enforces the phone number format (###) ###-####.\\n\\n- It loops through each character position (0-14 for the phone number format) and inserts/appends the character to the text string at the appropriate position based on the length. \\n\\n- It only allows numeric digits 0-9 to be entered. All other characters are rejected.\\n\\n- Pos is updated after each valid character to keep track of the insertion point in the string.\\n\\n- This ensures the phone number is built up character by character following the expected format. Invalid characters or formats will be rejected.\\n\\nSo in summary, it provides custom input validation functionality for phone numbers by enforcing a specific format and only allowing numeric digits to be entered in the correct positions.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/VertexShakeB.cs\&quot;:\&quot;This file contains a script that animates the vertex colors of a Text Mesh Pro text object.\\n\\nKey functions:\\n\\n- AnimateVertexColors(): The main coroutine that performs the animation loop.\\n\\n- ON_TEXT_CHANGED(): Callback that fires when the text object regenerates its mesh. Marks that the vertex data needs to be re-copied. \\n\\n- Awake(): Gets a reference to the Text Mesh Pro component.\\n\\n- Start(): Starts the animation coroutine.\\n\\nInside the animation loop it:\\n\\n- Copies the vertex data from the text object meshes \\n- Loops through each character\\n- Applies random scaling and rotation transforms\\n- Pushes the modified vertex data back to the text object meshes\\n- Yields to smooth out the animation\\n\\nSo in summary, it copies and animates the vertex positions each frame to shake/distort the text for a glitchy visual effect.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/Benchmark03.cs\&quot;:\&quot;This file contains a script that benchmarks different text rendering methods in Unity:\\n\\n- It defines an enum BenchmarkType that specifies which rendering method to test (TMP SDF mobile, TMP SDF mobile SSD, TMP SDF, TMP bitmap mobile, TextMesh bitmap).\\n\\n- It allows setting the number of samples to test and the source font asset. \\n\\n- In Start():\\n  - It creates a TMP Font Asset based on the selected benchmark type.\\n  - It runs the specified number of samples:\\n    - For TMP benchmarks, it creates a GameObject, adds a TextMeshPro component, sets the font/text/size etc.\\n    - For TextMesh benchmark, it creates a GameObject, adds a TextMesh component, sets the font/text/size etc.\\n\\nKey functions:\\n\\n- BenchmarkType enum: Specifies which rendering method to test\\n- Start(): Runs the benchmark by creating the specified number of text objects \\n- TMP_FontAsset.CreateFontAsset: Creates a TMP Font Asset for the selected rendering mode\\n- Adds TextMeshPro or TextMesh components to render the text\\n\\nSo in summary, it benchmarks different text rendering techniques in Unity by creating test text objects and measuring performance.\&quot;,\&quot;/Assets/Scripts/Player/PlayerInput.cs\&quot;:\&quot;This file defines the player input actions and bindings for a Unity game.\\n\\nKey things it does:\\n\\n- Defines an InputActionAsset that contains the input maps and bindings\\n- Sets up an InputActionMap called \\\&quot;Player\\\&quot; that contains the Move action\\n- Binds the WASD keys to the Move action\\n- Defines a PlayerInput class that manages the asset\\n- Allows adding/removing callbacks for the player actions\\n- Exposes the player actions through a PlayerActions struct\\n- Defines an IPlayerActions interface for receiving action callbacks\\n\\nKey functions:\\n\\n- constructor that loads the asset from JSON\\n- Dispose to clean up the asset\\n- FindAction to get references to actions \\n- bindings property to access all bindings\\n- PlayerActions struct to expose player input map\\n- AddCallbacks/RemoveCallbacks to register for callbacks\\n- OnMove callback defined in IPlayerActions interface\\n\\nSo in summary, it defines the player input schema and provides an API to interact with and receive callbacks from the player input actions.\&quot;,\&quot;/Assets/Scripts/UI/CreateItems.cs\&quot;:\&quot;This file contains a script that is used to randomly generate item stats in a game.\\n\\nThe key things it does:\\n\\n- Defines enum types for item type (head, armor, etc), and quality (grey, green, etc)\\n\\n- Has references to stat ranges for each quality level\\n\\n- SetStats function takes in a Stats object and randomly assigns 2 stats to it based on the item type\\n\\n   - Picks random stats from predefined ranges based on the item type\\n\\n   - Assigns random values for the stats from the appropriate quality range\\n\\n- CreateQuality function randomly determines the item quality\\n\\n   - Uses chance percentages to determine if it\\u0027s orange, gold, purple, etc\\n\\n   - Sets the statsCreateRange variable to the appropriate range\\n\\nKey functions:\\n\\n- SetStats - Generates and assigns random stats to a Stats object\\n- CreateQuality - Determines the item quality level \\n- GetRandomEnumValue - Helper to randomly pick an enum value\\n\\nSo in summary, it handles randomly generating item stats, quality levels, and assigning values from the appropriate stat ranges.\&quot;,\&quot;/Assets/Joystick Pack/Scripts/Joysticks/FloatingJoystick.cs\&quot;:\&quot;This file defines a FloatingJoystick class that inherits from the Joystick class. It is used to create a floating joystick control in Unity.\\n\\nKey functions:\\n\\n- Start() - Called when the joystick is initialized. Sets the background image to inactive by default.\\n\\n- OnPointerDown() - Called when the user presses on the joystick. Sets the background position to the touch position and activates it. Calls the base OnPointerDown().\\n\\n- OnPointerUp() - Called when the user releases the joystick. Deactivates the background image. Calls the base OnPointerUp(). \\n\\n- It overrides the base Joystick behavior by not anchoring the background image by default. This allows it to float freely under the user\\u0027s touch instead of being anchored to a specific position.\\n\\nSo in summary, it creates a floating joystick control by deactivating the background image by default and moving it to the touch position on pointer down, rather than anchoring it.\&quot;,\&quot;/Assets/Scripts/UI/StatsCreateRange.cs\&quot;:\&quot;This StatsCreateRange scriptable object class is used to define a range of random values that can be used to generate stats for game objects like characters.\\n\\nKey functions/properties:\\n\\n- It is marked with [CreateAssetMenu] so it can be created as an asset in the Unity editor.\\n\\n- It contains public float properties for min and max values of different stats like damage, armor, health, speed, etc. \\n\\n- The min/max pairs define a random range that stats can be generated within.\\n\\n- Additional properties define chance percentages for different quality levels when generating random items.\\n\\nSo in summary, this class defines all the possible stats that can be randomly generated and the valid ranges for those stats. It provides a centralized place to configure the random stat generation system and allows those ranges/chances to be tweaked from the Unity editor. Scripts that generate random stats would reference an instance of this class to get the valid ranges to randomize within.\&quot;,\&quot;/Assets/Scripts/Attack/Shoot.cs\&quot;:\&quot;This Shoot script controls the shooting behavior of a character/enemy:\\n\\n- It gets references to the PerceptionComponent, Animations, Stats, and DamageableObject components.\\n\\n- Shooting() is called to actually shoot a projectile. It gets a bullet from the AmmoPool, sets its damage, position/rotation, and target.\\n\\n- IsInRange() checks if the target is within the character\\u0027s attack range. \\n\\n- Update() is called each frame:\\n\\n  - Gets the target from PerceptionComponent\\n\\n  - Checks if in range\\n\\n  - Increments time\\n\\n  - If not moving, plays attack animation\\n\\n  - Shoots if time exceeds attack speed, resets time\\n\\n  - Otherwise stops attack animation\\n\\nKey functions:\\n\\n- Shooting() - Spawns and shoots a projectile\\n- IsInRange() - Checks if target is in range \\n- Update() - Main logic for shooting over time if in range\\n\\nSo in summary, it handles the shooting behavior, projectile spawning, targeting, range checking, and animation playback.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/TMP_UiFrameRateCounter.cs\&quot;:\&quot;This file contains a script that displays a frame rate counter overlay in a Unity scene.\\n\\nKey functions:\\n\\n- Awake(): Initializes the frame counter UI elements like text mesh pro component and sets up positioning based on anchor position enum.\\n\\n- Update(): Called every frame, tracks frame count and time to calculate FPS. Formats and displays FPS and MS text using HTML color tags. \\n\\n- Set_FrameCounter_Position(): Positions the frame counter UI element based on the selected anchor position enum value (top left, bottom left, top right, bottom right). Sets pivot, anchors and anchored position accordingly.\\n\\n- Start(): Resets frame count and last interval tracking variables. \\n\\n- OnGUI(): Renders the GUI text. \\n\\nIt tracks frames over a time interval to calculate real-time FPS, formats it with color coded text, and displays the overlay text in the scene anchored to a corner based on the selected position enum. This allows displaying an FPS counter overlay for debugging performance.\&quot;,\&quot;/Assets/Joystick Pack/Examples/JoystickPlayerExample.cs\&quot;:\&quot;This file controls player movement using a virtual joystick input in a Unity game.\\n\\nKey functions:\\n\\n- FixedUpdate() - Called every physics update to apply movement.\\n\\n- Gets input from the VariableJoystick component for vertical and horizontal axis. \\n\\n- Combines the vertical and horizontal input into a direction vector. \\n\\n- Applies the direction as a force to the attached Rigidbody component\\u0027s velocity. \\n\\n- The speed variable controls movement speed.\\n\\n- It uses AddForce in VelocityChange mode to smoothly move the player object based on joystick input each physics step.\\n\\nSo in summary, it takes input from a virtual joystick, calculates a movement direction, and applies that as physics force to the player Rigidbody to control character movement in the game world. The VariableJoystick component would handle rendering and input for the virtual joystick interface.\&quot;,\&quot;/Assets/Scripts/UI/Items.cs\&quot;:\&quot;This Items.cs script controls item objects in the game.\\n\\nKey functions/properties:\\n\\n- type - The Type of item as defined in the CreateItems class (e.g. weapon, armor, etc.)\\n\\n- quality - The Quality of the item (e.g. common, rare, epic, etc.) \\n\\n- stat - An array of Stats enum values defining what stats the item affects \\n\\n- statValue - An array of float values defining how much each stat is affected\\n\\n- Start() - Gets the Stats component and CreateItems component on the item and initializes them\\n\\n- SetParam() - Sets the type, quality, stats array and stat values of the item \\n\\n- stats - The Stats component that stores the item\\u0027s stat values\\n\\n- createItems - The CreateItems component used to generate the item stats\\n\\nSo in summary, this script defines the type, quality and stats of an item in the game. It links the item to its Stats and CreateItems components to generate and store the stat values. The SetParam function configures the item properties.\&quot;,\&quot;/Assets/Joystick Pack/Examples/JoystickSetterExample.cs\&quot;:\&quot;This file controls and demonstrates the functionality of a VariableJoystick component in Unity.\\n\\nKey functions:\\n\\n- ModeChanged(int index) - Sets the joystick mode (fixed, floating, dynamic) based on the index passed in.\\n\\n- AxisChanged(int index) - Sets the joystick axis options (both, horizontal only, vertical only) based on the index and updates the background sprite. \\n\\n- SnapX(bool value), SnapY(bool value) - Enables/disables snapping to axes for the X and Y axes.\\n\\n- Update() - Continuously updates the text display to show the current joystick direction value. \\n\\n- It has references to the VariableJoystick, text display, background image and axis sprite assets.\\n\\nThe purpose is to provide UI controls to dynamically change the joystick settings and demonstrate reading the joystick direction value in real-time. This allows testing and experimenting with the different joystick modes and configurations.\&quot;,\&quot;/Assets/Joystick Pack/Scripts/Base/Joystick.cs\&quot;:\&quot;This file defines a Joystick class that implements a virtual joystick input for mobile/touch controls.\\n\\nKey functions:\\n\\n- OnPointerDown, OnDrag, OnPointerUp: Event handlers for touch input. OnDrag handles moving the joystick handle position based on touch input.\\n\\n- Horizontal, Vertical, Direction: Properties that return the current horizontal, vertical and direction vector values of the joystick.\\n\\n- HandleRange, DeadZone: Properties to configure the range and deadzone of joystick input. \\n\\n- Start: Initialization function that sets up the UI elements like background and handle. \\n\\n- HandleInput: Handles mapping touch input to normalized joystick values, applying deadzone and limiting magnitude.\\n\\n- FormatInput: Formats input based on AxisOptions like horizontal only, vertical only or both.\\n\\n- SnapFloat: Snaps float values to discrete directions based on angle thresholds.\\n\\n- ScreenPointToAnchoredPosition: Converts a screen touch position to an anchored UI position.\\n\\nSo in summary, it provides a reusable virtual joystick component that can be used to control in-game objects via touch input on mobile/touchscreens.\&quot;,\&quot;/Assets/Scripts/DamageableObject.cs\&quot;:\&quot;This DamageableObject.cs file defines an abstract base class for damageable game objects in Unity.\\n\\nKey things:\\n\\n- It is an abstract class, meaning it cannot be directly instantiated and must be inherited from.\\n\\n- It defines a single abstract method GetHealthSystem(). Abstract methods must be implemented by child classes.\\n\\n- GetHealthSystem() returns a HealthSystem component. This allows child classes to expose their health system implementation.\\n\\n- It does not define any other methods or properties - it is just a base class definition to be inherited from.\\n\\nKey functions:\\n\\n- GetHealthSystem() - Abstract method that must return the HealthSystem component for the inheriting object. This provides a common interface to access health systems across different damageable objects.\\n\\nSo in summary, it provides a base class that damageable game objects can inherit from, requiring them to implement a GetHealthSystem() method to expose their health system implementation in a standardized way. This allows damageable objects to be treated generically in code that needs to interact with their health.\&quot;,\&quot;/Assets/Scripts/Player/Experience.cs\&quot;:\&quot;This Experience.cs script manages a player\\u0027s experience points and leveling up.\\n\\nKey functions:\\n\\n- AddExp() - Adds experience points to the player\\u0027s exp total\\n- CheckIsLvlUp() - Checks if the player has enough exp to level up, levels them up if so \\n- levelUped property - Calculates how many level ups the player gets from excess exp after leveling up\\n- LvlUp event - Called when the player levels up to notify other scripts\\n\\nIt tracks the player\\u0027s current exp (exp), max exp needed to level up (maxExp), and current level (lvl). When exp exceeds maxExp, it levels the player up, increases maxExp for the next level, and fires the LvlUp event. AddExp() is used to grant exp, which then checks for level ups.\\n\\nSo in summary, it manages the player\\u0027s experience system - tracking exp, leveling up when thresholds are met, and notifying other scripts of level up events.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/TMP_TextEventHandler.cs\&quot;:\&quot;This file defines a TMP_TextEventHandler class that handles pointer interactions with a TMP_Text component in Unity.\\n\\nKey functions:\\n\\n- Awake() - Gets references to the TMP_Text component, camera, and canvas.\\n\\n- LateUpdate() - Checks for pointer intersections with characters, words, lines, and links in the text. Calls selection event functions if something is selected. \\n\\n- OnPointerEnter(), OnPointerExit() - Interface functions for pointer enter/exit events.\\n\\n- SendOnCharacterSelection(), SendOnSpriteSelection(), etc - Functions that invoke the appropriate selection event if listeners are registered.\\n\\n- onCharacterSelection, onSpriteSelection, etc - Public properties that expose the selection event delegates.\\n\\nIt allows registering callbacks/listeners for when the pointer selects different elements in the text like characters, words, lines, or links. It handles checking for selections each frame and invoking the appropriate event.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/VertexZoom.cs\&quot;:\&quot;This file contains a script called VertexZoom that animates the vertex colors of a TMP Text object in Unity.\\n\\nKey functions:\\n\\n- AnimateVertexColors(): The main coroutine that handles the animation loop. It retrieves the vertex data, scales and transforms the vertices randomly for each character, then updates the text mesh.\\n\\n- ON_TEXT_CHANGED(): Callback that fires when the text object regenerates, to flag that the vertex data needs to be re-fetched. \\n\\n- Awake(): Gets a reference to the TMP_Text component.\\n\\n- Start(): Starts the animation coroutine. \\n\\n- It retrieves the vertex/UV/color data, scales each character randomly, sorts the quads by scale, updates the mesh vertices/UVs/colors, then yields to repeat the process over time for an animated zoom effect.\\n\\nSo in summary, it animates the text mesh by randomly scaling and transforming each character\\u0027s vertices over time to produce a vertex zooming animation on the text.\&quot;,\&quot;/Assets/Scripts/UI/InventorySlot.cs\&quot;:\&quot;This InventorySlot.cs script defines a component that represents a single slot in an inventory UI.\\n\\nKey things it does:\\n\\n- Stores a reference to the current Item object in the slot (currentItem)\\n\\n- Stores the type of item that can go in the slot (type, referencing the Type enum from the CreateItems script)\\n\\nThere are no explicit functions defined, but it provides properties to:\\n\\n- Get/set the currentItem stored in the slot\\n\\n- Get the allowed type for the slot\\n\\nThis allows other scripts to:\\n\\n- Populate the slot by assigning an Item to currentItem\\n\\n- Check the type to determine if an Item can be dropped into the slot\\n\\n- Access the current item for things like displaying an icon etc.\\n\\nSo in summary, it defines the basic data for a single inventory slot that other scripts can interact with to manage what item is stored there and validate item types.\&quot;,\&quot;/Assets/Joystick Pack/Scripts/Editor/VariableJoystickEditor.cs\&quot;:\&quot;This file defines a custom editor for the VariableJoystick script.\\n\\nKey functions:\\n\\n- OnEnable() - Finds the serialized properties for moveThreshold and joystickType.\\n\\n- OnInspectorGUI() - Calls the base OnInspectorGUI and sets the pivot of the background RectTransform to center. \\n\\n- DrawValues() - Calls the base DrawValues() and draws GUI fields for the moveThreshold and joystickType properties. \\n\\n- moveThreshold property - Threshold distance from center for joystick to start moving.\\n\\n- joystickType property - Type of joystick being used (digital, analog etc).\\n\\nSo in summary, it provides a custom inspector GUI for the VariableJoystick script, allowing editing of the moveThreshold and joystickType properties directly in the inspector. It also centers the background RectTransform pivot.\&quot;,\&quot;/Assets/Scripts/MineObjects/TreeMine.cs\&quot;:\&quot;This TreeMine script is attached to tree game objects in the scene. It handles the mining interaction between a player and the tree.\\n\\nKey functions:\\n\\n- Start() - Gets references to the tree\\u0027s HealthSystem component and the player.\\n\\n- Mine() - Starts the mining process by setting flags and calling the mine coroutine. \\n\\n- StopMine() - Stops mining by clearing flags.\\n\\n- MineTree() - Coroutine that continuously damages the tree\\u0027s health over time while playing mining animations, until mining is stopped. \\n\\n- OnDeath() - Called when the tree\\u0027s health reaches 0. Awards resources to the player and stops mining.\\n\\n- OnTriggerEnter/Exit(Collider) - Called when a player enters/exits the trigger volume. Starts/stops mining.\\n\\nSo in summary, it allows a player to mine a tree by continuously damaging its health over time, playing animations, and awarding resources when complete. The trigger volume handles starting/stopping the interaction.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/TMPro_InstructionOverlay.cs\&quot;:\&quot;This file contains a script that displays an instruction overlay text in the Unity scene.\\n\\nKey functions:\\n\\n- Awake(): Initializes the text mesh pro component, sets up the gameobject and text container, loads fonts/materials, sets initial position.\\n\\n- Set_FrameCounter_Position(): Positions the instruction text based on the selected anchor position enum. Calculates the world position based on the camera viewport.\\n\\n- It uses TextMeshPro to display overlay text that is not obstructed by other game objects. \\n\\n- Allows positioning the text in different corners of the screen by setting the anchor position enum.\\n\\n- Loads shared materials and fonts to style the text display.\\n\\n- Renders the text instructions directly in the scene view tied to the main camera transform for easy visibility.\\n\\nSo in summary, it provides an easy way to overlay basic instruction text in the scene view for examples and tutorials using TextMeshPro.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/VertexColorCycler.cs\&quot;:\&quot;This file contains a script that cycles the vertex colors of a TextMeshPro text object over time to animate it.\\n\\nThe key things it does:\\n\\n- Gets a reference to the TMP_Text component on the gameobject it\\u0027s attached to.\\n\\n- Starts a coroutine called AnimateVertexColors() on Start().\\n\\n- AnimateVertexColors() iterates through each character in the text over time:\\n\\n  - Gets the vertex color data for that character\\u0027s material\\n\\n  - Randomizes the vertex color of the first 4 vertices\\n\\n  - Calls UpdateVertexData() to push the new colors to the renderer\\n\\n  - Yields for a short time before moving to the next character\\n\\nKey functions:\\n\\n- AnimateVertexColors() - The coroutine that handles the color cycling over time\\n\\n- UpdateVertexData() - Called to push updated vertex data to the renderer \\n\\n- ForceMeshUpdate() - Forces an initial mesh update before starting animation\\n\\nSo in summary, it randomly changes the vertex colors of each character over time to animate the text object.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/TextMeshProFloatingText.cs\&quot;:\&quot;This file contains a script that spawns floating text objects above a game object and displays a countdown timer on them.\\n\\nKey functions:\\n\\n- Awake() - Stores references to the script\\u0027s transform and the main camera transform.\\n\\n- Start() - Initializes either a TextMeshPro or TextMesh component on the spawned floating text object based on the SpawnType variable. Starts a coroutine to display the countdown. \\n\\n- DisplayTextMeshProFloatingText()/DisplayTextMeshFloatingText() - Coroutines that handle displaying the countdown timer text on the floating object. Updates the text, position, color over time as it counts down. Waits a random time then resets.\\n\\n- It spawns a new GameObject to hold the text component. Handles positioning it above the script\\u0027s gameobject and aligning it to face the camera.\\n\\nThe main purpose is to spawn floating text objects that display a countdown timer, moving and fading them over time in a looping coroutine. This provides an example of using TextMeshPro or regular TextMesh components for floating text displays.\&quot;,\&quot;/ProjectSettings/Packages/com.unity.testtools.codecoverage/Settings.json\&quot;:\&quot;This file is for configuring code coverage settings in Unity.\\n\\nKey things about this file:\\n\\n- Location: ProjectSettings/Packages/com.unity.testtools.codecoverage/Settings.json\\n- Stores settings for the Unity code coverage package\\n- Allows configuring which assemblies/files to include/exclude from code coverage analysis\\n- The main setting is \\\&quot;m_DictionaryValues\\\&quot; which would contain include/exclude patterns\\n- By default it is empty, meaning all assemblies will be included in coverage\\n- You can add/remove values to m_DictionaryValues to customize the include/exclude filters\\n- Common uses are to exclude test assemblies or generated code from coverage results\\n- This allows focusing the results on just the code you want to measure\\n- The file format is JSON for easy editing of the include/exclude filters\\n\\nSo in summary, it contains the configuration for Unity\\u0027s code coverage package to define which files/assemblies should be analyzed during code coverage runs vs excluded from the results.\&quot;,\&quot;/Packages/packages-lock.json\&quot;:\&quot;This file is packages-lock.json. It is a lock file that describes the exact tree of dependencies that were installed during the last package resolution.\\n\\nSome key functions of this file:\\n\\n- It locks down the dependency tree so that other developers working on the project get the same dependency graph without needing to resolve it themselves.\\n\\n- It ensures repeatable and consistent builds by preventing dependency changes between builds unless the lock file is updated.\\n\\n- It lists all the packages that are installed in the project, along with their version numbers. \\n\\n- It shows the dependency relationships between packages - which packages depend on which other packages.\\n\\n- It distinguishes between packages from the Unity registry/package manager vs built-in Unity packages.\\n\\n- It provides metadata for each package like the source it was installed from, its depth/level in the dependency tree, and a URL for the package source.\\n\\n- It prevents dependency conflicts and ensures compatible versions of packages and their dependencies are installed.\\n\\nSo in summary, it locks down and describes the exact dependency graph that was resolved during the last package installation or update. This ensures consistent and repeatable builds.\&quot;,\&quot;/Assets/Scripts/Player/Stats.cs\&quot;:\&quot;This Stats.cs script manages the player character\\u0027s stats in a game.\\n\\nKey things it does:\\n\\n- Defines various float properties to track stats like damage, armor, health, etc.\\n\\n- Has an enum to define all stat types for easy reference \\n\\n- On level up, calls AddStat() to increment relevant stats\\n\\n- AddStat() function updates the float value of a given stat property \\n\\n- Starts by setting bigAttackRange equal to attackRange\\n\\n- Has LevelUp() method that gets called on level up to increment stats\\n\\n- Stores stats that can be incremented on level up vs only purchasable stats\\n\\n- Tracks wood collection amount \\n\\n- Checks for a BasePlayer component to hook into level up events\\n\\nKey functions:\\n\\n- AddStat() - Increments the value of a given stat property\\n- LevelUp() - Called on level up to increment relevant stats \\n- BigRangeCheck() - Sets bigAttackRange equal to attackRange\\n- Start() - Sets up initial values and level up event handler\\n\\nSo in summary, it manages all player character stats and progression via leveling up.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/ChatController.cs\&quot;:\&quot;This ChatController script manages a basic chat UI in Unity.\\n\\nKey functions:\\n\\n- AddToChatOutput(string) - Called when the input field is submitted. It formats the input with a timestamp and adds it to the chat display output text component.\\n\\n- OnEnable()/OnDisable() - Adds/removes a listener to the input field\\u0027s onSubmit event to call AddToChatOutput.\\n\\n- ActivateInputField() - Keeps the input field active after submitting text. \\n\\n- Sets the scrollbar value to 0 to scroll to the bottom after new text is added.\\n\\nOverall it takes user input from the input field, timestamps and formats it, adds it to the chat display output text, resets the input field, and scrolls the chat box to the bottom on new messages. This allows basic chat functionality within a Unity UI.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/Benchmark04.cs\&quot;:\&quot;This file contains a script called Benchmark04 that is used to benchmark the performance of TextMeshPro vs the legacy TextMesh component in Unity.\\n\\nThe key things it does:\\n\\n- Spawns text GameObjects repeatedly with increasing font sizes from MinPointSize to MaxPointSize in steps\\n- Can spawn using either TextMeshPro (default) or TextMesh \\n- Positions the text objects vertically spaced based on the font size\\n- Configures the TextMeshPro or TextMesh component on each object with the font size, text content, etc.\\n- Keeps track of the vertical line height as objects are spawned\\n\\nKey functions:\\n\\n- Start() - Main setup and spawning loop\\n- Configures camera orthographic size\\n- Spawns gameobjects and configures TextMeshPro or TextMesh based on SpawnType\\n- Tracks line height of spawned objects\\n\\nSo in summary, it benchmarks the performance of repeatedly spawning many text objects with increasing font sizes to test rendering and memory usage limits of the two components.\&quot;,\&quot;/Assets/Scripts/Enemy/Enemy.cs\&quot;:\&quot;This Enemy.cs script controls the movement and behavior of enemy game objects in Unity.\\n\\nKey things it does:\\n\\n- Inherits from DamageableObject which handles health/damage systems\\n- Stores references to the MovementComponent and HealthSystem on the enemy object\\n- Handles random movement by calling Moving() coroutine periodically\\n- Moving() sets a random movement direction and waits before pausing  \\n- Pause() waits and then resumes movement by calling Moving() again\\n- RandomMovement() actually moves the enemy using the MovementComponent\\n- GetHealthSystem() returns the HealthSystem component\\n\\nKey functions:\\n\\n- Start() - Starts the initial Moving() coroutine\\n- Update() - Handles random movement when not paused  \\n- Moving() - Sets random direction and waits before pausing\\n- Pause() - Waits and resumes movement  \\n- RandomMovement() - Moves the enemy using the direction set\\n- GetHealthSystem() - Returns the HealthSystem reference\\n\\nSo in summary, it controls random patrol movement and pausing behavior for enemies using coroutines, while also providing access to health/damage systems.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/TeleType.cs\&quot;:\&quot;This file contains a script called TeleType that implements a teletype effect for a TextMeshPro text component.\\n\\nKey functions:\\n\\n- Awake(): Gets a reference to the TextMeshPro component and initializes some text and formatting properties.\\n\\n- Start(): Coroutine that reveals the text character by character over time by incrementing the maxVisibleCharacters property. \\n\\n- It waits 1 second after revealing the full text, then switches the text to the second label. This repeats to create a looping teletype effect.\\n\\n- It yields on WaitForSeconds to pause revealing characters and switching text for a timed interval, creating the \\\&quot;typing\\\&quot; animation effect.\\n\\nSo in summary, it uses a coroutine to incrementally reveal TextMeshPro text over time to simulate a teletype/typing effect that loops between two text labels.\&quot;,\&quot;/Assets/Joystick Pack/Scripts/Joysticks/VariableJoystick.cs\&quot;:\&quot;This file defines a VariableJoystick class that extends the base Joystick class. It adds variable functionality to the standard joystick.\\n\\nKey things it does:\\n\\n- Allows setting the joystick type to Fixed, Floating or Dynamic via the SetMode function. This controls how the background sprite behaves.\\n\\n- Overrides OnPointerDown and OnPointerUp to handle positioning the background sprite differently based on joystick type. \\n\\n- Overrides HandleInput to allow the background sprite to move dynamically based on input magnitude if the type is Dynamic. \\n\\n- Adds a MoveThreshold property to control when the background starts moving for Dynamic type.\\n\\n- Keeps track of the fixed position for Fixed type joysticks.\\n\\nKey functions:\\n\\n- SetMode - Sets the joystick type which controls behavior\\n- OnPointerDown - Positions background on pointer down\\n- OnPointerUp - Hides background on pointer up  \\n- HandleInput - Handles input and moves background if Dynamic type\\n- MoveThreshold property - Threshold for dynamic movement\\n\\nSo in summary, it extends the basic joystick to add variable and dynamic behavior to the background sprite.\&quot;,\&quot;/Assets/Scripts/DamageSystem/DamageSystem.cs\&quot;:\&quot;This DamageSystem script handles damaging and applying damage over time to objects with a HealthSystem component.\\n\\nKey functions:\\n\\n- SetDamage(float damage) - Sets the amount of damage this system deals.\\n\\n- OnTriggerEnter(Collider other) - Called when another collider enters the trigger. Checks if it has a HealthSystem and damages it if so. Starts coroutine to repeatedly damage if damagePeriod is set.\\n\\n- OnTriggerExit(Collider other) - Called when another collider exits the trigger. Stops damage coroutine if active. \\n\\n- OnDamagableDeath - Called when the damaged object dies. Stops damage coroutine.\\n\\n- TakeDamage() - Coroutine that repeatedly damages the target object every damagePeriod seconds. \\n\\n- OnDestroy() - Called when this object is destroyed. Stops any active damage coroutines.\\n\\nSo in summary, it handles applying single or repeated damage over time to HealthSystem equipped objects that enter its trigger volume. The damage coroutine ensures damage is applied periodically as long as the target remains in trigger.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/TextMeshSpawner.cs\&quot;:\&quot;This file spawns random text objects in the scene using either TextMeshPro or the legacy TextMesh component.\\n\\nKey functions:\\n\\n- Start() - Main spawning loop that iterates NumberOfNPC times\\n  - Checks SpawnType and spawns either a TextMeshPro or TextMesh object\\n  - Sets properties like position, text, color\\n  - Adds a TextMeshProFloatingText component to make the text float\\n\\n- Awake() - Empty for now\\n\\n- TextMeshSpawner() - MonoBehaviour class that handles the spawning\\n\\n- SpawnType - Determines whether to use TextMeshPro or TextMesh\\n- NumberOfNPC - Number of text objects to spawn \\n- TheFont - Reference to font asset for TextMesh\\n\\nSo in summary, it randomly spawns text objects around the scene that float upwards, using either the new TextMeshPro or legacy TextMesh components based on the SpawnType setting.\&quot;,\&quot;/Assets/Scripts/Spawn.cs\&quot;:\&quot;This Spawn script handles spawning enemies/objects in the game.\\n\\nKey functions:\\n\\n- Start() - Sets up references and registers to the HealthSystem death event.\\n\\n- OnDeath() - Called when the spawned object dies via the HealthSystem. Deactivates the object, activates the death UI, and starts the delay coroutine. \\n\\n- Delay() - Coroutine that waits for the delaySpawnTime, fully restores the HealthSystem, deactivates the death UI, repositions the object back to the spawn point, and reactivates it.\\n\\n- ActiveUI() - Helper function to activate/deactivate the death text UI element.\\n\\nSo in summary, it handles:\\n\\n- Spawning objects from a spawn point \\n- Detecting when the object dies\\n- Delaying respawning for a set time\\n- Restoring health and reactivating the object after the delay\\n- Showing/hiding death UI when objects die/respawn\\n\\nIt provides the core spawning/respawning logic for enemies/objects in the game.\&quot;,\&quot;/Packages/manifest.json\&quot;:\&quot;This file is called manifest.json and it is located in the Packages folder of a Unity project.\\n\\nThe key functions of this file are:\\n\\n- It defines all the package dependencies for the Unity project. The dependencies object lists each package name and required version.\\n\\n- When a package is added or updated in the Unity Package Manager, it will check this file to ensure the project has the correct package versions installed.\\n\\n- It allows Unity to manage and track which packages the project relies on. If a package dependency is removed, Unity can detect issues.\\n\\n- New packages can be added by editing this file and defining the package name and version as a new entry in the dependencies object. \\n\\n- The package versions listed are locked, so updating an existing package requires explicitly changing the version number in this file.\\n\\nSo in summary, it defines all package dependencies for a Unity project to ensure correct and expected packages are installed and their versions are locked down. The Package Manager uses this file to manage packages for the project.\&quot;,\&quot;/Assets/Scripts/MineObjects/MineObjects.cs\&quot;:\&quot;This MineObjects.cs script is for objects in a mine that can take damage.\\n\\nIt inherits from the DamageableObject class.\\n\\nKey things it does:\\n\\n- Gets the HealthSystem component attached to the object on Start. This is used to track the object\\u0027s health.\\n\\n- Overrides the GetHealthSystem function from DamageableObject to return the attached HealthSystem component. \\n\\n- This allows any code that interacts with DamageableObjects to get the HealthSystem of a MineObject and modify its health.\\n\\nKey functions:\\n\\n- Start() - Gets the HealthSystem component\\n- GetHealthSystem() - Returns the attached HealthSystem\\n\\nSo in summary, it:\\n\\n- Allows mine objects to take damage \\n- Tracks their health via a HealthSystem component\\n- Exposes the HealthSystem to other scripts that interact with damageable objects\\n\\nThis allows mine objects like enemies, crates, etc to have health that can be depleted when they take damage from the player or environment.\&quot;,\&quot;/Assets/TextMesh Pro/Examples \\u0026 Extras/Scripts/WarpTextExample.cs\&quot;:\&quot;This file contains a script that warps/curves text along an animation curve over time.\\n\\nKey functions:\\n\\n- WarpText(): The main coroutine that performs the text warping animation. It loops through each character, calculates the warp offset/rotation based on the animation curve, applies the transform to the character vertices, and updates the text mesh.\\n\\n- CopyAnimationCurve(): Copies an AnimationCurve so the original is not modified.\\n\\n- Start(): Starts the WarpText coroutine on startup. \\n\\n- Awake(): Gets a reference to the TMP_Text component.\\n\\nIt works by:\\n\\n1. Generating the text mesh vertices \\n2. Looping through each character\\n3. Calculating the warp offset/rotation from the animation curve\\n4. Applying the transform to the character vertices  \\n5. Updating the text mesh with the modified vertices\\n6. Waiting a fraction of a second then repeating\\n\\nThis animates the text warping/curving along the specified animation curve over time.\&quot;}&quot;}" />
  </component>
</project>